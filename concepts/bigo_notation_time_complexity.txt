ðŸ“˜ Big-O Notation â€“ Time Complexity Notes
ðŸ“Œ What is Big-O?
Big-O notation describes:
How the running time of an algorithm grows as input size (n) increases.
It does NOT measure exact time.
It measures growth rate.

ðŸ“Œ Why Big-O is Important?
Helps compare algorithms
Predicts performance for large data
Helps write scalable code
Used heavily in interviews

ðŸ“Œ Basic Idea
If input size increases:
How much more time will the program take?
That growth is Big-O.

ðŸ“Œ Common Time Complexities
ðŸŸ¢ O(1) â€” Constant Time
Time does NOT depend on input size.
Example:
arr[0]
Even if array has 10 or 10 lakh elements â†’ same time.

ðŸŸ¢ O(n) â€” Linear Time
Time grows directly with input size.
Example:
for (let i = 0; i < n; i++) {
   console.log(i);
}
If n doubles â†’ time doubles.

ðŸŸ¡ O(nÂ²) â€” Quadratic Time
Nested loops.
Example:
for (let i = 0; i < n; i++) {
   for (let j = 0; j < n; j++) {
       console.log(i, j);
   }
}
If n doubles â†’ time becomes 4x.

ðŸŸ¡ O(log n) â€” Logarithmic Time
Problem size reduces each step.
Example:
Binary search.

ðŸ”´ O(nÂ³) â€” Cubic Time
Three nested loops.
Very slow for large inputs.

ðŸ“Œ How to Find Big-O (Important Rule)
Given:
T = an + b
Steps:
1ï¸âƒ£ Find fastest growing term
2ï¸âƒ£ Remove constants
Examples:
T = 5n + 2        â†’ O(n)
T = 3nÂ² + 4n + 7  â†’ O(nÂ²)
T = 100           â†’ O(1)
T = nÂ³ + nÂ²       â†’ O(nÂ³)

ðŸ“Œ Big-O From Code
Single loop
for (let i = 0; i < n; i++)
Big-O: O(n)

Two separate loops
for (i=0; i<n; i++)
for (j=0; j<n; j++)
Time:
n + n = 2n
Big-O: O(n)
(We ignore constants)

Nested loop
for (i=0; i<n; i++)
   for (j=0; j<n; j++)
Time:
n Ã— n = nÂ²
Big-O: O(nÂ²)

ðŸ“Œ Important Big-O Rules
Rule 1: Ignore constants
O(2n) = O(n)
O(100n) = O(n)

Rule 2: Keep highest power
O(nÂ² + n) = O(nÂ²)

Rule 3: Different loops â†’ add
O(n + m)

Rule 4: Nested loops â†’ multiply
O(n Ã— m)

ðŸ“Œ Best / Average / Worst Case
Example: Linear search
Best case â†’ O(1)
Worst case â†’ O(n)
In interviews, we usually talk about: Worst case


ðŸ“Œ Growth Speed (Fast â†’ Slow)
O(1)   â†’ fastest
O(log n)
O(n)
O(n log n)
O(nÂ²)
O(nÂ³)
O(2â¿)  â†’ worst

ðŸ“Œ Quick Memory Trick
Ask:
How many times does the loop run?

Code Pattern	Big-O
No loop	O(1)
One loop	O(n)
Nested loop	O(nÂ²)
Binary search	O(log n)